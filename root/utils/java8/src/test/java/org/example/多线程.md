# 锁
## 可重入锁
意思就是单个线程可以获取锁以后，还可以再次获取这个锁而不会被阻塞。只是锁计数器会加1，解锁会减1.减为0就没有锁了。
避免了递归调用的死锁问题。新版本`ReentrantLock` 和`synchronized` 都是可重入锁。

## 偏向锁
研究发现很多锁经常之被一个线程占有，不如直接这个线程和这个锁绑定起来（在对象头中的偏向锁绑定线程id）。 
这样这个线程拿锁就用通过cas自旋去判断有没有加锁。
但是一旦有锁竞争，偏向锁就会暂停所有设计到当前偏向锁的线程，然后一直尝试去掉当前线程的偏向锁。
去掉偏向锁后。
然后所有线程重新开始拿锁，但是锁是只可升级，不可降级，所以jvm会安装锁竞争的程度升级为轻量级锁 或 重量级锁。

## 轻量级锁
1.线程尝试获取锁时，会在当前线程的栈帧中创建记录锁状态的栈锁。这时对象头中的的mark word会拷贝到栈锁中。
2.使用cas尝试锁定，如果cas尝试将对象头中的的mark word指向为当前线程栈锁，那么就代表当前线程获取锁成功。
3.线程执行完后，还是使用cas尝试将对象头的mark word还原。
4.如果在轻量级锁期间，另外线程也尝试获取锁，那么轻量锁就尝试升级为重量级锁，这个行为叫膨胀。
升级条件就是看其他线程在竞争锁的时候，锁自旋次数，超过阈值就会升级。这样避免了cpu的空转。
5.这个锁很适合锁很短时间的代码块。

## 重量级锁
就是一个线程获取到锁后，会阻塞其他尝试获取该锁的线程，知道该线程执行完毕，才会通知其他线程去尝试加锁。
但是这样有一个很大缺点就是，需要频繁的进行上下文切换。很消耗资源。

## cas
线程安全的无锁并发控制。
CAS 操作涉及三个操作数：

内存地址 V：需要操作的变量地址。
旧的预期值 A：期望内存中当前的值。
新的更新值 B：希望写入内存的新值。
CAS 操作的流程如下：

比较：检查内存地址 V 上的值是否与预期值 A 相等。
交换：如果 V 的值与 A 相等，则将其更新为新的值 B。如果不相等，说明该值已经被其他线程修改过，操作失败，返回当前 V 的值。
CAS 操作的执行是原子的，即在多线程环境中，CAS 可以确保只有一个线程能够成功地更新变量的值，而其他线程则会失败并重试。

但是这样会产生aba问题，解决办法就行先判断，再修改，或者直接同步互斥锁也行。

## 自旋适应
在JDK 6中对自旋锁的优化，引入了自适应的自旋。
自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。
如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，
进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。
另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。
有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，
虚拟机就会变得越来越“聪明”了。

## 锁消除 锁粗化
jvm判断一段代码根本没有共享数据，就会直接锁消除。
如果检测到一个线程多次对同一个对象加锁，jvm会锁粗化，将多个加锁合并为一个。

## 无同步方案
就是不要产生共享变量。
又称可重入代码。





